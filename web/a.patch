*** Begin Patch
*** Update File: main.cpp
@@
-#include <WiFi.h>
-#include <WiFiUdp.h>
+#include <WiFi.h>
+#include <WiFiUdp.h>
+#include <Preferences.h>
@@
-// ===== Wi-Fi設定 =====
-const char* ssid     = "Fight Club";      ///< WiFi SSID
-const char* password = "soap1999";        ///< WiFi パスワード
+// ===== NVSに保存する設定 =====
+Preferences prefs;
+struct AppConfig {
+  // 制御系
+  uint16_t soilDryThreshold = 1900;
+  uint16_t pumpOnMs         = 5000;
+  uint16_t initWaitMs       = 5000;
+  uint16_t deepSleepWaitMs  = 1000;
+  // 通信系
+  char ssid[32]      = "Fight Club";
+  char pass[64]      = "soap1999";
+  char udpAddr[16]   = "192.168.0.214";
+  uint16_t udpPort   = 12345;
+  // 簡易PSK（SoftAPプロビジョニング時の署名）
+  char psk[32]       = "change_me";
+} cfg;
+
+void loadConfig() {
+  prefs.begin("plantmon", true);
+  cfg.soilDryThreshold = prefs.getUShort("soil", 1900);
+  cfg.pumpOnMs         = prefs.getUShort("pump", 5000);
+  cfg.initWaitMs       = prefs.getUShort("init", 5000);
+  cfg.deepSleepWaitMs  = prefs.getUShort("dsw", 1000);
+  String s = prefs.getString("ssid",  cfg.ssid);
+  String p = prefs.getString("pass",  cfg.pass);
+  String a = prefs.getString("uaddr", cfg.udpAddr);
+  cfg.udpPort          = prefs.getUShort("uport", 12345);
+  String k = prefs.getString("psk",   cfg.psk);
+  s.toCharArray(cfg.ssid, sizeof(cfg.ssid));
+  p.toCharArray(cfg.pass, sizeof(cfg.pass));
+  a.toCharArray(cfg.udpAddr, sizeof(cfg.udpAddr));
+  k.toCharArray(cfg.psk, sizeof(cfg.psk));
+  prefs.end();
+}
+
+void saveConfig() {
+  prefs.begin("plantmon", false);
+  prefs.putUShort("soil", cfg.soilDryThreshold);
+  prefs.putUShort("pump", cfg.pumpOnMs);
+  prefs.putUShort("init", cfg.initWaitMs);
+  prefs.putUShort("dsw",  cfg.deepSleepWaitMs);
+  prefs.putString("ssid",  cfg.ssid);
+  prefs.putString("pass",  cfg.pass);
+  prefs.putString("uaddr", cfg.udpAddr);
+  prefs.putUShort("uport", cfg.udpPort);
+  prefs.putString("psk",   cfg.psk);
+  prefs.end();
+}
@@
-// ===== UDP送信先 =====
-const char* udpAddress = "192.168.0.214"; ///< UDP受信先IPアドレス
-const int udpPort = 12345;                ///< UDPポート番号
-WiFiUDP udp;
+// ===== UDP送信 =====
+WiFiUDP udp;           // センサデータ送信用（既存ポート）
+WiFiUDP ctrlUdp;       // 設定受信用（SoftAP/通常時に一時使用）
+const uint16_t CTRL_PORT = 34567;               // プロビジョニング受信ポート
+const uint32_t PROVISION_WINDOW_MS = 600000UL;  // SoftAP待機 10分
@@
-// ===== 時間・制御定数 =====
-const int INIT_ON_MSEC = 5000;               ///< 起動後の安定待ち時間(ms)
-const int DEEP_SLEEP_WAIT_MSEC = 1000;       ///< Deep Sleep前の待ち時間(ms)
-const int PUMP_ON_MSEC = 5000;               ///< ポンプON時間(ms)
-const int SOIL_DRY_THRESHOLD = 1900;         ///< 土壌乾燥しきい値(ADC)
+// ===== 既定値（NVS未設定時に使用） =====
+const int INIT_ON_MSEC         = 5000;  ///< デフォルト起動待ち:contentReference[oaicite:5]{index=5}
+const int DEEP_SLEEP_WAIT_MSEC = 1000;  ///< デフォルト待ち:contentReference[oaicite:6]{index=6}
+const int PUMP_ON_MSEC_DEF     = 5000;
+const int SOIL_DRY_DEF         = 1900;
@@
 void handlePump(int soilRaw) {
   digitalWrite(PUMP_PIN, HIGH);
-  delay(PUMP_ON_MSEC);
+  delay(cfg.pumpOnMs);
   digitalWrite(PUMP_PIN, LOW);
 }
@@
-bool sendUDP(const SensorData& data) {
-  WiFi.begin(ssid, password);
+bool tryConnectWiFi(uint32_t timeout_ms=15000) {
+  WiFi.mode(WIFI_STA);
+  WiFi.begin(cfg.ssid, cfg.pass);
+  uint32_t t0 = millis();
+  while (WiFi.status() != WL_CONNECTED && millis()-t0 < timeout_ms) delay(200);
+  return WiFi.status() == WL_CONNECTED;
+}
+
+void reportConfigToServer() {
+  // 設定スナップショットをサーバへUDP:12346で送信
+  WiFiUDP u; u.beginPacket(cfg.udpAddr, 12346);
+  uint8_t mac[6]; WiFi.macAddress(mac);
+  char js[512];
+  snprintf(js, sizeof(js),
+    "{\"type\":\"config\",\"mac\":\"%02X:%02X:%02X:%02X:%02X:%02X\","
+    "\"ssid\":\"%s\",\"udpAddr\":\"%s\",\"udpPort\":%u,"
+    "\"soil\":%u,\"pump_ms\":%u,\"init_ms\":%u,\"dsw_ms\":%u}",
+    mac[0],mac[1],mac[2],mac[3],mac[4],mac[5],
+    cfg.ssid, cfg.udpAddr, cfg.udpPort,
+    cfg.soilDryThreshold, cfg.pumpOnMs, cfg.initWaitMs, cfg.deepSleepWaitMs);
+  u.write((const uint8_t*)js, strlen(js));
+  u.endPacket();
+}
+
+bool sendUDP(const SensorData& data) {
+  if (!tryConnectWiFi()) return false;  // 既存はbegin+待機:contentReference[oaicite:7]{index=7}
@@
-  udp.begin(WiFi.localIP(), udpPort);
+  udp.begin(WiFi.localIP(), cfg.udpPort);  // 互換維持（送信に必須ではない）
@@
-  udp.beginPacket(udpAddress, udpPort);
+  udp.beginPacket(cfg.udpAddr, cfg.udpPort);
   udp.write((uint8_t*)packet, strlen(packet));
-  return udp.endPacket();
+  bool ok = udp.endPacket();
+  // ついでに設定スナップショットを通知
+  reportConfigToServer();
+  return ok;
 }
+
+// ---- SoftAPプロビジョニング（接続失敗時のみ）----
+void startProvisionAP() {
+  WiFi.mode(WIFI_AP);
+  uint8_t m[6]; esp_read_mac(WIFI_IF_AP, m);
+  char apSsid[32]; snprintf(apSsid, sizeof(apSsid), "PlantMon-%02X%02X", m[4], m[5]);
+  WiFi.softAP(apSsid, "plantmon");
+  WiFi.setTxPower(WIFI_POWER_MINUS_1dBm);
+  ctrlUdp.begin(CTRL_PORT);
+
+  uint32_t t0 = millis();
+  while (millis() - t0 < PROVISION_WINDOW_MS) {
+    int sz = ctrlUdp.parsePacket();
+    if (sz > 0) {
+      char buf[384]; int n = ctrlUdp.read(buf, sizeof(buf)-1); buf[n]=0;
+      // 超軽量JSONパース
+      auto findStr=[&](const char* key, char* out, size_t cap)->bool{
+        String s(buf); int i=s.indexOf(String("\"")+key+"\"");
+        if(i<0) return false; i=s.indexOf(':',i); if(i<0) return false;
+        int q1=s.indexOf('\"',i+1), q2=s.indexOf('\"',q1+1);
+        if(q1<0||q2<0) return false; String v=s.substring(q1+1,q2); v.toCharArray(out,cap); return true;};
+      auto findInt=[&](const char* key, int* out)->bool{
+        String s(buf); int i=s.indexOf(String("\"")+key+"\"");
+        if(i<0) return false; i=s.indexOf(':',i); if(i<0) return false;
+        *out = s.substring(i+1).toInt(); return true;};
+
+      // PSKチェック
+      char inKey[32] = ""; findStr("key", inKey, sizeof(inKey));
+      if (strcmp(inKey, cfg.psk) != 0) {
+        const char* nack="{\"ack\":0,\"err\":\"psk\"}";
+        ctrlUdp.beginPacket(ctrlUdp.remoteIP(), ctrlUdp.remotePort());
+        ctrlUdp.write((uint8_t*)nack, strlen(nack)); ctrlUdp.endPacket();
+        continue;
+      }
+
+      bool needReboot=false; int v;
+      if (findInt("soil",&v))    cfg.soilDryThreshold=v;
+      if (findInt("pump_ms",&v)) cfg.pumpOnMs=v;
+      if (findInt("init_ms",&v)) cfg.initWaitMs=v;
+      if (findInt("dsw_ms",&v))  cfg.deepSleepWaitMs=v;
+
+      char s[32]; char p[64]; char a[16];
+      if (findStr("ssid", s, sizeof(s)))  { strncpy(cfg.ssid, s, sizeof(cfg.ssid)); needReboot=true; }
+      if (findStr("pass", p, sizeof(p)))  { strncpy(cfg.pass, p, sizeof(cfg.pass)); needReboot=true; }
+      if (findStr("uaddr", a, sizeof(a))) { strncpy(cfg.udpAddr, a, sizeof(cfg.udpAddr)); }
+      if (findInt("uport",&v))            { cfg.udpPort=(uint16_t)v; }
+
+      saveConfig();
+
+      // ACK返送（現設定）
+      char ack[256];
+      snprintf(ack, sizeof(ack),
+        "{\"ack\":1,\"ssid\":\"%s\",\"uaddr\":\"%s\",\"uport\":%u,"
+        "\"soil\":%u,\"pump_ms\":%u,\"init_ms\":%u,\"dsw_ms\":%u}",
+        cfg.ssid, cfg.udpAddr, cfg.udpPort,
+        cfg.soilDryThreshold, cfg.pumpOnMs, cfg.initWaitMs, cfg.deepSleepWaitMs);
+      ctrlUdp.beginPacket(ctrlUdp.remoteIP(), ctrlUdp.remotePort());
+      ctrlUdp.write((uint8_t*)ack, strlen(ack)); ctrlUdp.endPacket();
+
+      if (needReboot) { delay(300); WiFi.softAPdisconnect(true); ESP.restart(); }
+    }
+    delay(10);
+  }
+  ctrlUdp.stop();
+  WiFi.softAPdisconnect(true);
+}
@@
-void setup() {
-  delay(INIT_ON_MSEC);
+void setup() {
+  loadConfig();
+  if (cfg.initWaitMs == 0) cfg.initWaitMs = INIT_ON_MSEC;
+  if (cfg.pumpOnMs   == 0) cfg.pumpOnMs   = PUMP_ON_MSEC_DEF;
+  if (cfg.soilDryThreshold == 0) cfg.soilDryThreshold = SOIL_DRY_DEF;
+  delay(cfg.initWaitMs); // 既存: 起動後安定待ち:contentReference[oaicite:8]{index=8}
@@
-  if (data_before.soil > SOIL_DRY_THRESHOLD) {
+  if (data_before.soil > cfg.soilDryThreshold) {
     handlePump(data_before.soil);
     pumpActivated = true;
     delay(100);  // 電圧・電流の安定待ち
   }
@@
-  if (pumpActivated) {
+  if (pumpActivated) {
     // 駆動前後を送信（2回）
-    sendUDP(data_before);
+    if (!sendUDP(data_before)) {
+      // 通常接続に失敗 → SoftAPで10分待受
+      startProvisionAP();
+    }
     delay(100);  // 送信間隔
-    sendUDP(data_after);
+    if (!sendUDP(data_after)) {
+      startProvisionAP();
+    }
   } else {
     // 1回だけ送信（駆動してない）
-    sendUDP(data_before);
+    if (!sendUDP(data_before)) {
+      startProvisionAP();
+    }
   }
 
-  delay(DEEP_SLEEP_WAIT_MSEC);
+  uint16_t waitMs = cfg.deepSleepWaitMs ? cfg.deepSleepWaitMs : DEEP_SLEEP_WAIT_MSEC;
+  delay(waitMs);
   esp_sleep_enable_timer_wakeup(600e6); // 10分スリープ
   esp_deep_sleep_start();
 }
*** End Patch
